# Шпаргалка по JavaScript

---

# JavaScrpit

`use strict` - строгий режим выполнения кода, активация новых возможностей языка. По умолчанию отключен, чтобы работал легаси код.

- Не позволяет случайно создать глобальные переменные
- Требует уникальность имен параметров функции
- `this` = `undefined` в глобальной области видимости
- Перехватывает распространение ошибки, выдавая исключения
- Может вызвать проблемы совместимости с браузерами, которые не поддерживают режим

## Типы данных

- Примитивные, содержит только одно значение:
    - `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(2531)`.
    - `bigint` для целых чисел произвольной длины.
    - `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    - `boolean` для `true`/`false`.
    - `null` для неизвестных значений – отдельный тип, имеющий одно значение `null`.
    - `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение `undefined`.
    - `symbol` для уникальных идентификаторов.
- Не примитивный:
    - `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

- Имеет две формы: `typeof x` или `typeof(x)`.
- Возвращает строку с именем типа. Например, `"string"`.

`typeOf(null) === object`

## Преобразование типов

### Строковое преобразование. String(value)

```jsx
'1' + 2 = "12”
2 + 2 + '1' = "41"
6 - '2' = 4
'6' / '2' = 3
null + 1 = 1
undefined + 1 = NaN
" \t \n" - 2 = -2, \t и \n — управляющие символы
```

### Численное преобразование.Number(value), +value

| Значение | Преобразуется в… |
| --- | --- |
| undefined | NaN |
| null | 0 |
| true / false | 1 / 0 |
| string | Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN. |

### Логическое преобразование. Boolean(value), !!value

| Значение | Становится… |
| --- | --- |
| 0, null, undefined, NaN, "" | false |
| любое другое значение | true |

## Приоритет операторов

| Приоритет | Название | Обозначение |
| --- | --- | --- |
| … | … | … |
| 15 | унарный плюс | + |
| 15 | унарный минус | - |
| 14 | возведение в степень | ** |
| 13 | умножение | * |
| 13 | деление | / |
| 12 | сложение | + |
| 12 | вычитание | - |
| … | … | … |
| 2 | присваивание | = |
| … | … | … |

## Инкремент, декремент

```jsx
let counter = 1;
let a = ++counter;

alert(a); // 2, операция -> присваивание
```

```jsx
let counter = 1;
let a = counter++; 

alert(a); // 1, присваивание -> операция
```

## Сравнение

```jsx
Строки - посимвольно по Unicode. Даже строки из чисел
'Коты' > 'Кода' → true
"2" > "12" → true
```

```jsx
Разные типы - приводятся к числу
'2' > 1 → true
```

```jsx
null === undefined → false
null == undefined → true
При сравнении с другими, преобразуются к числам - null = 0, undefined = NaN.
Не равны любому другому значению

NaN === NaN → false
NaN == NaN → false
Не равно любому другому значению, включая себя
isNaN(NaN); // true
```

## Логические операторы

- ИЛИ `||`, вернет `true`, если какой-либо из аргументов `true`
Возвращает **первое истинное** значение или **последнее**, если такое значение не найдено.
- И `&&`, вернет `true`, если оба аргумента `true`
Возвращает **первое ложное** значение или **последнее**, если такое значение не найдено.
- НЕ `!`, приводит аргумент к логическому типу, возвращает противоположное.
Двойное `!!` используют для преобразования к логическому типу.
- Оператор нулевого слияния `??`, возвращает **первый “определенный” аргумент**, если он не `null/undefined`, иначе **второй**.
Используется для присвоения переменным значений по умолчанию.
`height = height ?? 100;`
Запрещено использовать вместе с `||` или `&&` без явно указанного приоритета, то есть без скобок.
- Приоритет: `!` > `&&` > `||` = `??`

## Цикл for…of

Выполняет перебор элементов массивов, строк, `map` и `set`

```jsx
const numbers = [1, 2, 3, 4, 5];

for (const number of numbers) {
  console.log(number);
}
```

## `Map`, `Set`, `WeakMap`, `WeakSet`

`Map` - коллекция пар "ключ-значение".
`WeakMap` - ключи-объекты автоматически удаляются из коллекции, если на них нет других ссылок. Элементы в WeakMap также нельзя перебрать или просмотреть.

`Set` - коллекция уникальных значений.
`WeakSet` - автоматически удаляет элементы, на которые нет других ссылок, что предотвращает утечки памяти. Элементы в WeakSet нельзя перебрать или просмотреть.

```jsx
const myMap = new Map([
  ['one', 1],
  ['two', 2],
  ['three', 3],
]);

const mySet = new Set([1, 2, 3, 4, 5]);
```

## Hoisting, поднятие

Переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.

`var` всплывает, `// undefined`

`let`, `const` не всплывают, область видимости - блочная `// ReferenceError: a is not  defined`

Function Declaration всплывает

Function Expression не всплывает

Temporal Dead Zone, временная мертвая зона - переменная будет создана, когда интерпретатор зайдет в область видимости, но она будет недоступна до тех пор, пока выполнение кода не дойдет до места их фактического объявления. Происходит выход из мертвой зоны.

## Область видимости, scope

Место, откуда мы имеем доступ к переменным или функциям.

- Глобальная- объявляется снаружи всех функций, видимы для любой функции
- Локальная, функциональная - объявляется и используется только внутри этой функции
- Блочная - для `let` и `const` - внутри фигурных скобок `{ … }`

## Функции

Функция - объект первого класса.

Если функция - это свойство объекта, она называется методом.

Результат функции с пустым `return` или без него – `undefined`

Функция высшего порядка - возвращает другие функции или принимает другую функцию в качестве аргумента. `map, forIn, reduce`.

Чистая функция - без побочных эффектов + при одинаковом наборе аргументов каждый раз возвращает одинаковый результат.

```jsx
Чистая
const sum = (x, y) => x + y;
sum(4, 4)
```

```jsx
Не чистая
let x = 4;
const sum = (y) => x +=y;
sum(4); // при изменении x функция будет возвращать разные значения, независимо от y
```

### Виды

1. Function Declaration создается до выполнения кода. Можно вызвать до объявления.
В строгом режиме, когда Function Declaration находится в блоке `{...}`, функция доступна везде внутри блока. Но не снаружи него.
    
    ```jsx
    function sayHi() {
    	alert( "Привет" );
    }
    ```
    
2. Function Expression создаётся, когда выполнение доходит до нее.
    
    ```jsx
    let sayHi = function() {
    	alert( "Привет" );
    };
    ```
    
3. Стрелочная функция
    
    ```jsx
    let func = (arg1, arg2, ...argN) => expression;
    
    let sum = (a, b) => {
      let result = a + b;
      return result;
    };
    ```
    

### Различия стрелочных и обычных

1. У стрелочных функций нет собственного контекста `this`. Они наследуют значение `this` из окружающего лексического контекста.
В обычных функциях контекст `this` зависит от того, как функция вызывается.
    
    ```jsx
    function Person() {
      this.age = 0;
    
      setInterval(function growUp() {
        this.age++; // `this` указывает на глобальный объект, а не на объект Person
      }, 1000);
    }
    
    const person = new Person(); // person.age не изменится
    ```
    
    ```jsx
    function Person() {
      this.age = 0;
    
      setInterval(() => {
        this.age++; // `this` наследуется от объекта Person
      }, 1000);
    }
    
    const person = new Person(); // person.age будет изменяться каждую секунду
    ```
    
2. Стрелочные функции не имеют собственного объекта `arguments`. Они наследуют объект `arguments` из окружающего лексического контекста.
В обычных функциях объект `arguments` содержит список аргументов, переданных функции при вызове.
    
    ```jsx
    const showArguments = () => {
      console.log(arguments);
    };
    
    showArguments(1, 2, 3); // Ошибка: arguments is not defined
    ```
    
    ```jsx
    function showArguments() {
      console.log(arguments);
    }
    
    showArguments(1, 2, 3); // Вывод: { '0': 1, '1': 2, '2': 3 }
    ```
    
3. Стрелочные функции не могут быть использованы в качестве конструкторов. Они не могут быть вызваны с оператором `new`.
Обычные функции могут быть использованы в качестве конструкторов.
    
    ```jsx
    const MyConstructor = () => {};
    
    const myInstance = new MyConstructor(); // Ошибка: MyConstructor is not a constructor
    ```
    
4. Поскольку стрелочные функции не могут быть использованы в качестве конструкторов, они не имеют свойства `prototype`.
У обычных функций есть свойство `prototype`, которое используется для наследования свойств и методов между объектами.
    
    ```jsx
    const arrowFunction = () => {};
    console.log(arrowFunction.prototype); // undefined
    
    function regularFunction() {}
    console.log(regularFunction.prototype); // { constructor: f }
    ```
    

### Передача параметра в функцию

Параметры всегда передаются в функцию по значению.

Если в функцию передают объект и изменяют его свойство, это изменение передается в объект при выходе из функции.

Если изменить значение переменной-объекта, это изменение не передается в объект, находящийся за пределами функции.

```jsx
// from и text - параметры
function showMessage(from, text) {
	alert( from + ', ' + text );
}

alert( from, text ); // from и text - аргументы
```

### Асинхронные функции

Синхронные - блокируют дальнейшее выполнение операций, выполняются одна за другой.

Асинхронные - не блокируют дальнейшее выполнение. Принимают колбэк, большая вложенность - callback hell. Запрос данных.

### Промисы, promises

Обертка для значения, которое может быть доступно сразу, в будущем или никогда.

Используются для упрощения работы с асинхронными операциями, такими как выполнение запросов к серверу, чтение файлов или выполнение таймаутов.

**Состояния:**

1. **Ожидание (pending)**: Исходное состояние промиса, значение еще не доступно.
2. **Исполнение (fulfilled)**: Операция успешно завершена и вернула результат.
3. **Отклонение (rejected)**: Операция завершена с ошибкой, и причина ошибки доступна.

**Методы:**

1. `then()` указывает действия, выполяемые, когда промис будет исполнен. 
2. `catch()` указывает действия, выполяемые, если промис будет отклонен.
3. `finally()` задает действия, которые будут выполнены в любом случае, независимо от того, был ли промис исполнен или отклонен.

```jsx
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Success!');
  }, 1000);
});

myPromise
  .then((result) => {
    console.log('Result:', result);
  })
  .catch((error) => {
    console.log('Error:', error);
  })
  .finally(() => {
    console.log('Operation completed');
  });
```

### Async/await

Синтаксический сахар для работы с промисами, который делает асинхронный код похожим на синхронный. `async` используется для объявления асинхронной функции, которая возвращает промис, а `await` используется для ожидания выполнения промиса.

```jsx
async function performAsyncOperation() {
  try {
    const result = await asyncOperation;
    console.log('Operation succeeded:', result);
  } catch (error) {
    console.error('Operation failed:', error);
  } finally {
    console.log('Operation completed');
  }
}

performAsyncOperation();
```

### IIFE, Immediately Invoked Function Expression, анонимная самовызывающаяся функция

Переменные, объявленные внутри функции, невидимы за ее пределами

```jsx
(function() {
  // Код внутри этой функции не влияет на глобальное пространство имен
  var localVar = 'I am a local variable';
  console.log(localVar); // Выведет 'I am a local variable'
})();

console.log(localVar); // Вызовет ошибку, так как localVar не определена в глобальном пространстве имен
```

### Замыкание, closures

Способность функции сохранять доступ к своим внешним переменным (окружению) даже после того, как родительская функция завершила свое выполнение. Вложенная функция замыкает на себе переменные и аргументы внешней функции

```jsx
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(3));  // 8
console.log(add10(3)); // 13
```

Когда мы вызываем `makeAdder(5)` и `makeAdder(10)`, мы создаем две новые функции с доступом к разным значениям `x` (5 и 10 соответственно). Затем, когда мы вызываем `add5(3)` и `add10(3)`, каждая из этих функций все еще имеет доступ к своему собственному значению `x`, хотя выполнение функции `makeAdder` уже завершилось.

### Псевдомассив arguments

Объект, доступный внутри функций JavaScript, который представляет собой список аргументов, переданных в функцию при вызове. Выглядит как массив, но является объектом.

Позволяет работать с переменным количеством аргументов без явного указания их в определении функции.

```jsx
function sum() {
	let total = 0;
	for (let i = 0; i < arguments.length; i++) {
		total += arguments[i];
	}
	return total;
}

console.log(sum(1, 2, 3, 4)); // Выведет 10
console.log(sum(1, 2, 3));    // Выведет 6
```

**Превращение в массив**

```jsx
let args = Array.prototype.slice.call(arguments); // ES5

const args = [...arguments]; //ES 6
```

### Таймеры

`setTimeout(func, 1000);` - вызовет 1 раз по истечению определенного времени.

`setInteval(func, 1000)`; - вызывает функцию постоянно через определенное время. Останавливается `clearInterval();`.

### Цепочка вызовов, chaining

```jsx
Math.abs(number)
		.toStringO
		.split('')
		.reduce((sum, eur) => +sum + +cur, 0);

myPromise.then(func1).then(func2).catch(func3);
```

```jsx
const counter = {
	count: 0,
	plusOne() {
		this.count++;
		return this;
	},
	minusOne() {
		this.count—;
		return this;
	showResult() {
		console.log(this.count);
		return this;
	}
}

counter.plusOne().plusOne().minusOne().plusOne().minusOne().showResult();
```

### Генераторы

Позволяют создавать итераторы, используя более простой и понятный синтаксис.

```jsx
function* makeRangelterator(start = 0, end = 4, step = 1) {
	let iterationCount = 0;
	for (let i = start; i < end; i += step) {
		iterationCount++;
		yield i;
	}
	return iterationCount;
}

const iterator = makeRangelterator();
iterator.next(); // { value: 0, done: false }
iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: 3, done: false }
iterator.next(); // { value: 4, done: true }

```

## Объекты

### Создание

1. Литерал объекта
    
    ```jsx
    const obj1 = {
      name: 'Alice',
      age: 30,
      greet: function() {
        console.log('Hello, ' + this.name);
      }
    };
    
    console.log(obj1.name); // Alice
    obj1.greet(); // Hello, Alice
    ```
    
2. Функция-конструктор
    
    ```jsx
    function Person(name, age) { // Название с большой буквы
      this.name = name;
      this.age = age;
      this.greet = function() {
        console.log('Hello, ' + this.name);
      };
    }
    
    const obj3 = new Person('Charlie', 28);
    
    console.log(obj3.name); // Charlie
    obj3.greet(); // Hello, Charlie
    ```
    
3. Конструктор `Object`
    
    ```jsx
    const obj2 = new Object();
    obj2.name = 'Bob';
    obj2.age = 25;
    obj2.greet = function() {
      console.log('Hello, ' + this.name);
    };
    
    console.log(obj2.name); // Bob
    obj2.greet(); // Hello, Bob
    ```
    
4. Метод `Object.create()`
    
    ```jsx
    const personPrototype = {
      greet: function() {
        console.log('Hello, ' + this.name);
      }
    };
    
    const obj4 = Object.create(personPrototype);
    obj4.name = 'Diana';
    obj4.age = 35;
    
    console.log(obj4.name); // Diana
    obj4.greet(); // Hello, Diana
    ```
    

### Виды

1. **Стандартные (нативные) встроенные объекты -** предоставляются самим языком JavaScript, и они доступны в любом контексте выполнения кода.
    - `Object`: Базовый тип объекта в JavaScript, от которого наследуются все остальные объекты.
    - `Array`: Объект для работы с упорядоченными коллекциями данных.
    - `Function`: Объект, представляющий функцию, которая может быть вызвана и выполнена.
    - `String`: Объект для работы со строками текста.
    - `Number`: Объект для работы с числами.
    - `Boolean`: Объект для работы с булевыми значениями (true или false).
    - `Date`: Объект для работы с датами и временем.
    - `Math`: Объект, предоставляющий математические функции и константы.
    - `RegExp`: Объект для работы с регулярными выражениями.
    - `Error`: Базовый объект для представления ошибок, таких как `TypeError`, `ReferenceError`, `SyntaxError` и других.
2. **host-объекты** - предоставляются средой выполнения (например, веб-браузером или Node.js)
    - `Window`: Глобальный объект в контексте выполнения веб-браузера.
    - `Document`: Объект, представляющий DOM-дерево HTML-страницы.
    - `Element`: Объект, представляющий HTML-элемент на странице.
    - `Event`: Объект для работы с событиями в веб-браузере.
    - `Node`: Базовый тип объекта для представления узлов в DOM-дереве.
    - `XMLHttpRequest` и `Fetch`: Объекты для выполнения асинхронных HTTP-запросов.
3. **Пользовательские объекты** - создаются разработчиками для конкретных приложений или библиотек. Они могут быть созданы с использованием литералов объектов, конструкторов функций или классов.
    
    ```jsx
    // Литерал объекта
    const person = {
    	name: 'Alice',
    	age: 30
    };
    
    // Конструктор функции
    function Car(make, model) {
    	this.make = make;
    	this.model = model;
    }
    const myCar = new Car('Toyota', 'Corolla');
    ```
    

### Перебор свойств объекта

```jsx
let user = {
	name: "John",
	age: 30,
	isAdmin: true
};

// for...in - проверка в объекте и прототипе
for (let key in user) {
	alert( key );  // name, age, isAdmin
	alert( user[key] ); // John, 30, true
}

// obj.hasOwnProperty(); - проверка только в объекте
clg(user.hasOwnProperty('name'));
```

### Порядок свойств объекта

Свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.

### Методы объектов

**Проверка на наличие свойства**

`clg(obj.hasOwnProperty(prop));` - вернет `true` или `false`.

`clg(prop in obj);` - вернет `true` или `false`.

`clg(obj[prop]);` - вернет значение, если его нет - `undefined`.

### Копирование объектов

При копировании переменной объекта **копируется ссылка**, но сам **объект не дублируется**. Если изменить копию, изменится оригинал.

Два объекта **равны** только в том случае, если это **один и тот же** объект.

**Поверхностная копия:**

```jsx
const user1 = {
  name: "John",
  age: 30
};

const user2 = user1;
```

**Глубокое копирование:**

- Через spread оператор
`const user22 = {...user1}`
- `Object.assign(dest, [src1, src2, src3...])`
    - Первый аргумент `dest` — целевой объект.
    - Остальные аргументы `src1, ..., srcN` (может быть столько, сколько необходимо) являются исходными объектами
    - Метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
    - Возвращает объект `dest`.
        
        ```jsx
        const *user2 = Object.assign({}, user1);
        // копирует все свойства user в пустой объект и возвращает его*
        ```
        
- Через JSON
    
    ```jsx
    const user2 = JSON.parse(JSON.stringify(user1));
    ```
    
- Создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.
    
    ```jsx
    const *user2 = {}; // новый пустой объект
    
    // давайте скопируем все свойства user в него
    for (let key in user1) {
      user2[key] = user1[key];
    }*
    // теперь clone это полностью независимый объект с тем же содержимым
    user2.name = "Pete"; // изменим в нём данные
    
    alert( user1.name ); // все ещё John в первоначальном объекте
    ```
    
- `_.cloneDeep(obj)` из Lodash

### this

Метод может использовать `this` для доступа к информации внутри объекта. Значение `this`вычисляется во время выполнения кода, в зависимости от контекста.

```jsx
let user = {
  name: "John",
  age: 30,

  sayHi() {
		*// "this" - это "текущий объект".
    alert(this.name);*
	}
};

user.sayHi(); // John
```

У стрелочных функций нет `this`, оно берется из внешней “нормальной” функции.

```jsx
let user = {
	firstName: "Ilya",
	sayHi() {
		let arrow = () => alert(this.firstName);
		arrow();
	}
};
user.sayHi(); // Ilya
```

Чтобы не терять контекст, используются `call()`, `apply()` или `bind()`

`func.call(user, ‘first’, ‘last’);`

`func.apply(user, [‘first’, ‘last’]);`

`func.bind(user, ‘first’, ‘last’);`

`call` и `apply` вызываются в момент применения.

`bind` создает функцию-обертку, которой можно присвоить переменную, затем вызвать в нужном месте

### **Прототип объекта**

Когда объект создается, он автоматически получает ссылку на другой объект, называемый его прототипом. При попытке получить доступ к свойству или методу объекта, который не существует на самом объекте, поиск продолжается в прототипе объекта и так далее, пока не будет найдено соответствующее свойство или метод или не будет достигнут конец цепочки прототипов.

Прототипное наследование позволяет объектам наследовать свойства и методы от своих прототипов, что может быть полезным для повторного использования кода и организации структуры кода.

**Создание объекта с прототипом**

Обычно все объекты имеют прототип по умолчанию (обычно это `Object.prototype`).

1. Используя функции-конструкторы:

```jsx
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

const person1 = new Person('Alice', 30);
person1.sayHello(); // Hello, my name is Alice and I am 30 years old.
```

1. Используя объект `Object.create()`:

```jsx
const personPrototype = {
  sayHello: function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
};

const person1 = Object.create(personPrototype);
person1.name = 'Alice';
person1.age = 30;
person1.sayHello(); // Hello, my name is Alice and I am 30 years old.
```

1. `obj2.__proto__ = obj1`

**Создание объекта без прототипа**

```jsx
const objWithoutPrototype = Object.create(null);

console.log(objWithoutPrototype); // {}
console.log(Object.getPrototypeOf(objWithoutPrototype)); // null
```

### Объектная обертка, boxing/unboxing

Объект оборачивает примитив, boxing - строку, число, булево значение - и дает доступ к свойствам и методам для этого значения. В момент исполнения кода примитив преобразуется в объект.

```jsx
const myString = 'Hello, World!';

console.log(myString.length); // 13
console.log(myString.toUpperCase()); // 'HELLO, WORLD!'
```

unboxing - обратный процесс, преобразование объектов в примитивы.
`valueOf()` и `toString()`

### `…rest` и `…spread`

Rest (остаточные параметры) оператор используется в параметрах функции, чтобы представить неопределенное количество аргументов в виде массива.

```jsx
function sum(...numbers) {
  return numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

Spread (расширение) оператор используется для разделения итерируемых объектов, таких как массивы или объекты, на отдельные элементы или пары "ключ: значение". Используется в массивах, объектах или в аргументах функций.

```jsx
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const combinedArray = [...array1, ...array2];
console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const combinedObj = { ...obj1, ...obj2 };
console.log(combinedObj); // { a: 1, b: 2, c: 3, d: 4 }
```

### Деструктуризация

Позволяет извлекать значения из массивов или свойства из объектов и присваивать их переменным в более удобном и лаконичном виде. Упрощение кода, читаемость, работа с вложенными данными.

```jsx
const colors = ['red', 'green', 'blue'];

const [firstColor, secondColor, thirdColor] = colors;

console.log(firstColor); // red
console.log(secondColor); // green
console.log(thirdColor); // blue
```

```jsx
const person = {
  name: 'Alice',
  age: 30,
  city: 'New York'
};

const { name, age, city } = person;

console.log(name); // Alice
console.log(age); // 30
console.log(city); // New York
```

### Статический метод класса

Метод, принадлежащий самому классу, а не его экземплярам (объектам).

Могут быть вызваны только на классе, на экземплярах класса - нет.

Используются для вспомогательных функций или операций, которые связаны с самим классом

```jsx
class MyClass {
  constructor() {
    this.instanceValue = 42;
  }

  instanceMethod() {
    console.log('This is an instance method');
  }

  static staticMethod() {
    console.log('This is a static method');
  }
}

const myInstance = new MyClass();

MyClass.staticMethod(); // Вывод: "This is a static method"

myInstance.staticMethod(); // Ошибка: myInstance.staticMethod is not a function

myInstance.instanceMethod(); // Вывод: "This is an instance method"
```

### `const`, `Object.freeze()` и **`Object.seal()`**

У `const` нельзя изменить значение переменной, но если это объект или массив, можно менять свойства и элементы.

```jsx
const myNumber = 42;
myNumber = 43; // Ошибка: Assignment to constant variable.

const myObject = { prop: 1 };
myObject.prop = 2; // Разрешено: свойство объекта может быть изменено
myObject = { prop: 3 }; // Ошибка: Assignment to constant variable.
```

`Object.seal()` запрещает добавлять и удалять свойства объекта. Разрешает изменять существующие свойства.

`Object.freeze()` запрещает добавлять, удалять или изменять свойства объекта. Вложенные объекты и массивы могут быть быть изменены, если тоже не заморожены.

```jsx
const myObject = { prop: 1 };
Object.freeze(myObject);

myObject.prop = 2; // Ошибка: Cannot assign to read only property 'prop' of object
myObject.newProp = 3; // Ошибка: Cannot add property newProp, object is not extensible
```

## Методы строк

`str.lenght` - длина строки.

`str[pos]` и `str.at(pos)` - символ, который занимает позицию `pos`.

`toLowerCase()` и `toUpperCase()` - меняют регистр символов.

`str.indexOf(substr, pos)` - ищет подстроку `substr` в строке `str`, начиная с позиции `pos`, и возвращает позицию, на которой располагается совпадение, либо `-1` при отсутствии совпадений.

`str.includes(substr, pos)` - возвращает `true`, если в строке `str` есть подстрока `substr`, либо `false`, если нет.

`str.startsWith` и `str.endsWith` - проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой.

`str.slice(start [, end])` - возвращает часть строки от `start` до (не включая) `end`.

`str.substring(start [, end])` - возвращает часть строки *между* `start` и `end` (не включая) `end`.

`str.substr(start [, length])` - возвращает часть строки от `start` длины `length`.

`str.trim()` - отрезает пробельные символы.

## Методы массивов

`Array.isArray(arr)` проверяет, является ли `arr` массивом.

`arr.length` - длина массива.

### Добавление/удаление элементов

`arr.pop()` – извлекает элемент из конца.

`arr.push(...items)` – добавляет элементы в конец,

`arr.shift()` – извлекает элемент из начала,

`arr.unshift(...items)` – добавляет элементы в начало.

`arr.splice(start[, deleteCount, elem1, ..., elemN])` - изменяет `arr` начиная с индекса `start`: удаляет `deleteCount` элементов и затем вставляет `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.

`arr.slice([start], [end])` - возвращает новый массив, в который копирует все элементы с индекса `start` до `end` (не включая `end`)

`arr.concat(arg1, arg2...)` - возвращает новый массив, включающий в себя элементы из `arr`, затем `arg1`, `arg2`

### Поиск среди элементов

`indexOf/lastIndexOf(item, pos)` – ищет `item`, начиная с позиции `pos`, и возвращает его индекс или `1`, если ничего не найдено.

`includes(value)` – возвращает `true`, если в массиве имеется элемент `value`, в противном случае `false`.

`find/filter(func)` – фильтрует элементы через функцию и отдаёт первое `find`/все значения `filter`, при прохождении которых через функцию возвращается `true`.

`findIndex` похож на `find`, но возвращает индекс вместо значения.

### Перебор элементов

`arr.forEach(function(item, index, array) { });` - запускает функцию для каждого элемента массива, ничего не возвращает, не изменяет начальный массив.

### Преобразование массива

`arr.map(function(item, index, array) { });` - возвращает новый массив из результатов вызова `func` для каждого элемента, не изменяет начальный массив.

`arr.sort();` - сортирует массив (как строки) *на месте*, меняя в нём порядок элементов.

`arr.sort((a, b) => a - b)` - по возрастанию

`arr.sort((a, b) => b - a)` - по убыванию

`arr.reverse();` - меняет *на месте* порядок элементов в `arr` на обратный.

`str.split(delim);` - разбивает строку на массив по заданному разделителю `delim`.

`arr.toString();` - создает строку из элементов `arr`.

`arr.join(glue);` - создаёт строку из элементов `arr`, вставляя `glue` между ними.

`arr.reduce(function(accumulator, item, index, array) { }, [initial]);` - функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:

- `accumulator` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),
- `item` – очередной элемент массива,
- `index` – его позиция,
- `array` – сам массив.

```jsx
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce(function(accumulator, currentValue) {
	return accumulator + currentValue;
}, 0);

console.log(sum); // 15
```

`arr.some(fn)/arr.every(fn);` - Функция `fn` вызывается для каждого элемента массива аналогично `map`. Если какие-либо `some`/все результаты `every` вызовов являются `true`, то метод возвращает `true`, иначе `false`.

`arr.fill(value, start, end);` - заполняет массив повторяющимися `value`, начиная с индекса `start` до `end`.

`arr.flat(depth)/arr.flatMap(fn);` - создаёт новый плоский массив из многомерного массива.

## Общая информация

### ООП, объектно-ориентированное программирование

Парадигма программирования, основанная на концепции использования объектов и их взаимодействия для построения программ.

**Приниципы:**

1. **Инкапсуляция**: Объединение данных и функций, которые обрабатывают эти данные, в объекте. Это позволяет скрыть детали реализации от внешнего кода и управлять доступом к данным объекта только через его методы.
Переменные и функции невидимы извне.
2. **Наследование**: Процесс создания нового класса на основе существующего класса. Новый класс наследует свойства и методы базового класса, что позволяет повторно использовать код и упрощает модификацию и расширение функциональности программы.
3. **Полиморфизм**: Полиморфизм означает способность объекта принимать разные формы. Одна функция может работать с разными объектами. Позволяет упростить код и делает его более гибким и расширяемым.
4. **Абстракция**: Абстракция — это процесс выделения наиболее важных характеристик объекта и игнорирования нерелевантных деталей. Абстракция позволяет сосредоточиться на общих аспектах объектов и создавать более простые и понятные модели решаемых задач.
Работа на верхнем уровне, нам не важно, что под капотом.

### SOLID

Пять ключевых принципов объектно-ориентированного программирования и проектирования, которые помогают создавать масштабируемые, удобные для сопровождения и легко изменяемые системы.

1. **S — Принцип единственной ответственности (Single Responsibility Principle, SRP)**: Этот принцип гласит, что каждый класс должен иметь только одну причину для изменения, то есть класс должен иметь только одну ответственность. Если класс имеет более одной ответственности, его сложнее изменять и поддерживать.
Каждый класс или часть кода должна заниматься только одной задачей.
2. **O — Принцип открытости/закрытости (Open/Closed Principle, OCP)**: Согласно этому принципу, классы и модули должны быть открыты для расширения, но закрыты для изменения. Это означает, что код должен быть спроектирован таким образом, чтобы его функциональность могла быть расширена, не изменяя сам код.
Возможность добавлять новые функции кода без изменения существующих.
3. **L — Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)**: Этот принцип гласит, что объекты класса-наследника должны иметь возможность заменить объекты базового класса без изменения поведения программы. Если наследник не может полностью заменить базовый класс, это может привести к ошибкам и неожиданному поведению.
Наследники должны сохранять свойства базового класса, чтобы их можно было заменить без проблем.
4. **I — Принцип разделения интерфейсов (Interface Segregation Principle, ISP)**: Согласно этому принципу, большие интерфейсы следует разбивать на более мелкие и специфичные, чтобы классы могли реализовывать только те методы, которые им нужны. Это предотвращает проблему "жирных интерфейсов" и уменьшает зависимости между классами.
Вместо того чтобы иметь один огромный инструмент, который делает всё, лучше иметь много маленьких инструментов, каждый из которых выполняет свою функцию.
5. **D — Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)**: Этот принцип гласит, что высокоуровневые модули не должны зависеть от низкоуровневых модулей, и оба должны зависеть от абстракций. Кроме того, абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций. Это позволяет снизить зависимость между модулями и упрощает замену их реализаций без изменения других частей системы.
Модули должны зависеть от абстракций, а не от конкретных реализаций.

### MVC, Model-View-Controller

Архитектурный шаблон проектирования, который разделяет приложение на три основные компонента: модель, представление и контроллер. Упрощает разработку, поддержку и тестирование.

**Компоненты:**

1. **Модель (Model):** Модель представляет собой структуру данных и бизнес-логику приложения. Она содержит все знания о предметной области, и ее задача — обрабатывать данные, выполнять бизнес-операции и хранить состояние приложения.
2. **Представление (View):** Представление отвечает за отображение данных на экране и формирование пользовательского интерфейса. Оно не знает о бизнес-логике, а лишь отображает данные, полученные от модели, и передает пользовательский ввод контроллеру.
3. **Контроллер (Controller):** Контроллер служит посредником между моделью и представлением. Он получает ввод от пользователя через представление, обрабатывает его и обновляет модель. Затем контроллер может обновить представление, чтобы отобразить изменения в модели.

### MVW, Model-View-Whatever

Гибкая архитектурная концепция, основанная на паттерне MVC.

"Whatever" - разработчики могут использовать любую структуру или архитектурный паттерн, который подходит для их конкретного случая. Это может быть классический контроллер, как в MVC, или другие варианты, такие как презентер (Presenter) в MVP (Model-View-Presenter) или ViewModel в MVVM (Model-View-ViewModel).

Часто используется в Angular.

### Императивность и декларативность

**Императивность** означает, что код описывает, *как* нужно выполнить задачу, пошагово указывая все действия и изменения состояния. Императивный код фокусируется на описании последовательности действий, которые нужно выполнить для достижения желаемого результата.

```jsx
const arr = [1, 2, 3, 4, 5];
const doubled = [];

for (let i = 0; i < arr.length; i++) {
  doubled.push(arr[i] * 2);
}
```

**Декларативность** означает, что код описывает, *что* нужно сделать, не вдаваясь в подробности реализации. Декларативный код фокусируется на описании желаемого результата, а не на указании последовательности действий для его достижения.

```jsx
const arr = [1, 2, 3, 4, 5];
const doubled = arr.map((x) => x * 2);
```

### Babel

Конвертирует современный JavaScript-код в более старую версию, чтобы обеспечить совместимость с большим количеством браузеров и сред выполнения. Используется вместе со сборщиками.

1. Транспилер - переписывает современный код в старый стандарт. ES6, TypeScript, JSX → ES5,4.
2. Полифил - проверяет, доступна ли нужная функциональность и предоставляет альтернативную реализацию.
Код, который добавляет новые функции в старые браузеры, чтобы они могли работать с современными веб-технологиями.
Обычно содержится в библиотеках - core.js, polyfill.io

# Браузер

## DOM, Document Object Model

Объектная модель документа, которую браузер создает в памяти компьютера, на основании html-кода, полученного от сервера.

html-код этот текст страницы а DOM это набор связанных объектов, созданных браузером при парсинге этого текста.

### Динамическое добавление элемента на html страницу

```jsx
// Создайте новый элемент <p>
const newElement = document.createElement('p');

// Добавьте класс элементу
newElement.classList.add('paragraph')

// Задайте текстовый контент для элемента
newElement.textContent = 'Hello, World!';

// Выберите родительский элемент (в данном случае <div> с id="container")
const container = document.getElementById('container');

// Добавьте новый элемент в родительский элемент
container.appendChild(newElement);
```

### Типы узлов DOM-дерева

Спецификация JS насчитывает 12 типов, на практике используются 4.

`element.nodeType` - проверка узла на тип, возвращает число.

1. **Элементы (Element):** Узлы-элементы представляют теги HTML или XML и являются основными строительными блоками веб-страницы. Они могут содержать атрибуты и другие узлы-элементы в качестве дочерних элементов.
2. **Текстовые узлы (Text):** Текстовые узлы представляют текстовый контент элементов. Все текстовые данные внутри элемента обрабатываются как текстовый узел.
3. **Комментарии (Comment):** Узлы-комментарии представляют комментарии в HTML или XML. Они игнорируются браузером при отображении страницы, но полезны для разработчиков для добавления пояснений и других заметок к коду.
4. **Узлы документа (Document):** Узел документа является корневым узлом DOM-дерева и представляет всю веб-страницу. Он предоставляет доступ к элементам и их атрибутам, а также имеет свойства и методы для манипулирования содержимым страницы.

### Перемещение под DOM-дереву

1. **parentNode:** Возвращает родительский узел элемента. Если элемент является корневым (например, узел **`<html>`**), то возвращает **`null`**.
2. **firstChild:** Возвращает первый дочерний узел элемента. Если у элемента нет дочерних узлов, возвращает **`null`**.
3. **lastChild:** Возвращает последний дочерний узел элемента. Если у элемента нет дочерних узлов, возвращает **`null`**.
4. **nextSibling:** Возвращает следующий соседний узел элемента (узел, следующий сразу после текущего). Если такого узла нет, возвращает **`null`**.
5. **previousSibling:** Возвращает предыдущий соседний узел элемента (узел, находящийся непосредственно перед текущим). Если такого узла нет, возвращает **`null`**.
6. **childNodes:** Возвращает коллекцию дочерних узлов элемента в виде NodeList. Если у элемента нет дочерних узлов, возвращает пустой NodeList.

Свойства, которые работают только с узлами-элементами (игнорируют текстовые узлы и другие типы узлов):

1. **parentElement:** Возвращает родительский элемент текущего элемента. Если элемент является корневым или у него нет родительского элемента, возвращает **`null`**.
2. **firstElementChild:** Возвращает первый дочерний элемент текущего элемента. Если у элемента нет дочерних элементов, возвращает **`null`**.
3. **lastElementChild:** Возвращает последний дочерний элемент текущего элемента. Если у элемента нет дочерних элементов, возвращает **`null`**.
4. **nextElementSibling:** Возвращает следующий соседний элемент текущего элемента. Если такого элемента нет, возвращает **`null`**.
5. **previousElementSibling:** Возвращает предыдущий соседний элемент текущего элемента. Если такого элемента нет, возвращает **`null`**.
6. **children:** Возвращает коллекцию дочерних элементов текущего элемента в виде HTMLCollection. Если у элемента нет дочерних элементов, возвращает пустой HTMLCollection.

### layout, painting и compositing

Три основных этапа рендеринга веб-страницы

1. **Layout (раскладка):** браузер определяет положение и размеры всех элементов на странице.
Браузер читает структуру HTML-документа, применяет к нему CSS-стили и вычисляет макетную модель (например, размеры элементов, отступы, границы и позиционирование).
Результатом этого этапа является "дерево макета" (layout tree), которое содержит всю информацию о положении и размерах элементов.
2. **Painting (рисование):** браузер отрисовывает визуальное представление элементов на странице.
Этот процесс включает в себя прорисовку текста, цветов, изображений, границ, теней и других визуальных свойств, определенных стилями CSS. Браузер использует информацию из дерева макета для определения, как именно должны отображаться элементы.
Результатом этого этапа является "дерево слоев" (paint tree), которое содержит информацию обо всех элементах, которые нужно нарисовать.
3. **Compositing (композиция):** браузер объединяет слои, созданные на этапе painting, и отображает итоговую страницу на экране.
Браузер может оптимизировать этот процесс, создавая отдельные слои для независимых частей страницы, которые можно обновлять без влияния на другие слои (например, элементы с анимацией или прокруткой). Это позволяет браузеру быстрее отображать изменения на странице, минимизируя области, которые нужно перерисовывать.

### innerHTML и outerHTML

`innerHTML` возвращает или изменяет HTML-содержимое элемента.

```jsx
// Получение содержимого элемента
const content = document.getElementById("my-element").innerHTML;

// Задание нового содержимого элемента
document.getElementById("my-element").innerHTML = "<p>Новый контент</p>";
```

`outerHTML` возвращает или изменяет полное HTML-описание элемента, включая его открывающий и закрывающий теги.

```jsx
// Получение полного HTML-описания элемента
const fullHtml = document.getElementById("my-element").outerHTML;

// Замена элемента на новый
document.getElementById("my-element").outerHTML = "<div><p>Новый контент</p></div>";
```

### AJAX

Асинхронный JS и XML

С помощью AJAX приложения могут отправлять данные на сервер и получать их с сервера асинхронно. Отделение логики представления (отрисовки html) от логики обмена данными.

Сейчас вместо XML используют JSON. Для работы с асинхронными запросами используют `fetch`

### Polling, опрос

Процесс периодической отправки запросов на сервер. Основан на HTTP.

Клиент отправляет запрос на сервер, и сервер "задерживает" ответ, пока у него не появится новая информация или не истечет тайм-аут.

После получения ответа клиент тут же отправляет новый запрос.

Альтернативы - WebSocket или Server-Sent Events.

```jsx
import React, { useState, useEffect } from 'react';

function App() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://api.example.com/data');
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    const intervalId = setInterval(fetchData, 5000); // Запрос на сервер каждые 5 секунд (5000 мс)

    // Очистка эффекта при размонтировании компонента
    return () => {
      clearInterval(intervalId);
    };
  }, []); // Обратите внимание на пустой массив зависимостей — это означает,
					//что useEffect будет выполнен только один раз при монтировании компонента

  return (
    <div>
      <h1>Data from server:</h1>
      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}
    </div>
  );
}

export default App;
```

### Server-Sent Events (SSE)

Основан на HTTP.

Клиент отправляет запрос на сервер, и сервер отправляет обновления клиенту по мере их поступления.

Однонаправленная связь: сервер может отправлять данные клиенту, но не наоборот.

### WebSocket

Протокол связи, который обеспечивает двустороннее постоянное соединение между клиентом и сервером через одно TCP-соединение. Онлайн-игры, чаты, приложения для совместной работы.

**Принцип работы WebSocket:**

1. **Установка соединения:** Для установки WebSocket-соединения клиент отправляет HTTP-запрос с заголовком `Upgrade`, указывающим, что он хочет перейти на протокол WebSocket. Если сервер поддерживает WebSocket, он отправляет ответ с соответствующим заголовком `Upgrade`, подтверждая переход на WebSocket. Это процесс называется "рукопожатием" (handshake).
2. **Обмен данными:** После установки соединения клиент и сервер могут обмениваться данными в виде "кадров" (frames) без необходимости повторного установления соединения. WebSocket-кадры могут содержать текстовые или бинарные данные, и их можно отправлять в любом направлении (от клиента к серверу или от сервера к клиенту). Обе стороны могут посылать данные независимо друг от друга, не дожидаясь ответа на предыдущий кадр.
3. **Закрытие соединения:** Любая из сторон может закрыть WebSocket-соединение, отправив кадр закрытия (close frame) с определенным кодом статуса и необязательным текстовым сообщением. Другая сторона должна ответить аналогичным кадром закрытия и завершить TCP-соединение.

**Открытие соединения:**

```jsx
const socket = new WebSocket('ws://example.com/ws');

// Обработчик события 'open': вызывается, когда соединение установлено
socket.addEventListener('open', (event) => {
  console.log('WebSocket connection opened:', event);
  // Теперь вы можете отправлять данные серверу:
  socket.send('Hello, WebSocket!');
});

// Обработчик события 'message': вызывается, когда клиент получает данные от сервера
socket.addEventListener('message', (event) => {
  console.log('WebSocket received message:', event.data);
});

// Обработчик события 'error': вызывается, когда возникает ошибка соединения
socket.addEventListener('error', (event) => {
  console.error('WebSocket encountered an error:', event);
});

// Обработчик события 'close': вызывается, когда соединение закрывается
socket.addEventListener('close', (event) => {
  console.log('WebSocket connection closed:', event);
});
```

### same-origin policy, принцип одинакового источника

Не позволяет JS выполнять запросы с другого домена, чтобы предотвратить потенциальные атаки и защитить данные пользователя.

### CORS, cross-origin resource sharing

Чтобы разрешить кросдоменные запросы используется CORS. Применяется только в браузере, не на сервере.

`Access-Control-Allow-Origin: [https://example.com](https://example.com/)`

### **`HTMLCollection`** и **`NodeList`**

**HTMLCollection**

- `HTMLCollection` - динамичная коллекцией, автоматически обновляется при изменении DOM.
- Возвращается в результате методов `document.getElementsByClassName()` или `element.getElementsByTagName()`.
- Может содержать только элементы типа `Element`.

**NodeList**

- `NodeList` - динамичная или статическая коллекция. Например, `element.childNodes` возвращает живую коллекцию, а `document.querySelectorAll()` возвращает статическую коллекцию.
- Может содержать объекты любого типа узлов (`Node`), такие как элементы (`Element`), текстовые узлы, комментарии и т.д.

У обоих есть свойство `length`

### Event Loop (цикл событий)

Позволяет JavaScript обрабатывать несколько задач без блокировки, несмотря на то, что язык является однопоточным.

Обрабатывает задачи из очереди задач, выполняя их по одной.

Обеспечивает эффективное управление асинхронными операциями, такими как AJAX-запросы, обработка таймаутов, обработка событий и промисы.

**Компоненты:**

1. **Стек вызовов (Call Stack)**: Cтруктура данных, в которой хранятся функции, ожидающие выполнения. JavaScript обрабатывает функции в порядке LIFO (последняя вошла, первая вышла).
2. **Очередь задач (Task Queue)**: Сруктура данных, в которой хранятся асинхронные задачи, ожидающие выполнения. Когда стек вызовов опустошается, цикл событий перемещает задачу из очереди задач в стек вызовов для ее выполнения.
3. **Цикл событий (Event Loop)**: Процесс, который следит за стеком вызовов и очередью задач. Если стек вызовов пуст, цикл событий берет первую задачу из очереди задач и помещает ее в стек вызовов.

### HTTP, Hypertext Transfer Protocol, протокол передачи гипертекста

Прикладной протокол, который служит основой для обмена данными между клиентами и серверами. `port 80`

Клиент отправляет запрос на сервер, а сервер отвечает, предоставляя запрошенный ресурс или информацию о статусе запроса.

Не хранит состояния, каждый запрос обрабатывается независимо от предыдущих запросов. Для сохранения состояния используют куки и сессии.

**HTTPS** - обеспечивает безопасное и зашифрованное соединение. Защищает личную информацию, пароли, платежные данные. `port 443`

Использует `ssl` или `tls` сертификат.

**Содержание:**

1. Стартовая строка - метод запроса, целевой URL, версия протокола
2. Заголовки
3. Тело запроса
    
    ```jsx
    //Стартовая строка
    POST /api/login HTTP/1.1
    
    // Заголовки
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
    Content-Type: application/json
    Content-Length: 45
    
    // Тело запроса для POST, PUT
    {
      "username": "testuser",
      "password": "testpassword"
    }
    ```
    

**Версии:**

1. **HTTP/1.0**: Первая версия протокола, введенная в 1996 году. Она имела ограниченные возможности и требовала открывать новое TCP-соединение для каждого запроса.
2. **HTTP/1.1**: Более продвинутая версия протокола, введенная в 1997 году. Внесла множество улучшений, таких как поддержка постоянных соединений, кэширование, сжатие и другие оптимизации.
3. **HTTP/2**: Введен в 2015 году и является наиболее широко используемой версией протокола на данный момент. Внес значительные улучшения в производительность, такие как мультиплексирование, сжатие заголовков и приоритизация запросов.
4. **HTTP/3**: Последняя версия протокола, введенная в 2020 году. Основное изменение заключается в использовании протокола QUIC вместо TCP для передачи данных, что улучшает производительность и надежность, особенно в условиях плохого качества соединения.

**Методы:**

1. `GET` - получает данные с сервера, не изменяет. `R`
2. `POST` - отправка данных на сервер. `C`
3. `PUT` - обновляет существующие данные, заменяют. `U`
4. `PATCH` - частично обновляет существующие данные, не заменяют.
5. `DELETE` - удаление данных. `D`
6. `HEAD` - получает как GET, но возвращает только заголовки, без тела.
7. `OPTIONS` - запрашивает и возвращает список поддерживаемых методов.
8. `CONNECT` - установка сетевого соединения.
9. `TRACE` - запрашивает сообщение с сервера, включая заголовки и тело.

### Cookies, куки

Фрагменты данных, которых хранятся в браузере и переда.тся между клиентом и сервером при каждом запросе. Сохранение пользовательских настроек, управление сессиями, аутентификация, отслеживание поведения пользователя на сайте.

Отправляются сервером в браузер через заголовок `Set-Cookie`.
Браузер их сохраняет и отправляет на сервер с каждым запросом через заголовок `Cookie`.

Имею ограниченный срок действия `expires` или `max-age`.

В JavaScript можно читать, создавать и удалять куки с помощью свойства `document.cookie`

```jsx
document.cookie = 'username=JohnDoe; expires=Fri, 01 Jan 2024 12:00:00 UTC; path=/';
```

### Cookie, localStorage и sessionStorage

| Характеристика | Cookie | localStorage | sessionStorage |
| --- | --- | --- | --- |
| Срок хранения данных | Ограничен (устанавливается разработчиком) | Бессрочно (пока не будет удалено пользователем или программно) | До конца сессии (пока вкладка/браузер не закрыт) |
| Объем хранилища | Ограничен (до 4 KB) | До 5-10 MB (зависит от браузера) | До 5-10 MB (зависит от браузера) |
| Тип данных | Только строки | Строки, объекты, числа, булевы значения (данные хранятся в виде строк, но могут быть сериализованы/десериализованы) | Строки, объекты, числа, булевы значения (данные хранятся в виде строк, но могут быть сериализованы/десериализованы) |
| Передача данных на сервер | Автоматически отправляются с каждым HTTP-запросом | Не отправляются на сервер автоматически | Не отправляются на сервер автоматически |
| Доступность между вкладками | Доступно на всех вкладках и окнах | Доступно на всех вкладках и окнах | Доступно только в рамках одной вкладки/окна |
| Безопасность при хранении данных | Меньше безопасности (так как отправляются на сервер) | Более безопасно (данные хранятся на стороне клиента) | Более безопасно (данные хранятся на стороне клиента) |

### Feature detection, Feature inference и User-Agent

**Feature detection** - используется для определения того, поддерживает ли браузер конкретную функцию или API. Предоставляет альтернативные решения, когда функция не поддерживается. Осуществляется с помощью JavaScript, проверяя наличие определенных объектов, свойств или методов.

**Feature inference** - предположениие, что наличие одной функции или API в браузере гарантирует наличие другой, связанной функции или API. 

**User-Agent** - это строка, которую браузер передает серверу в HTTP-заголовке **`User-Agent`** при каждом запросе. Содержит информацию о браузере, операционной системе и устройстве пользователя, а также о версии браузера и других деталях. Может быть легко подделан.

### Сборка мусора

Выполняется автоматически. Мы не можем ускорить или предотвратить её.

Объекты сохраняются в памяти, пока они достижимы.

Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом.

### Веб-компоненты

Набор технологий и стандартов, разработанных для создания масштабируемых, повторно используемых и кастомизированных элементов в веб-приложениях.

**Технологии:**

1. **Custom Elements**: Это спецификация, позволяющая разработчикам создавать собственные кастомные HTML-элементы с определенными поведением и свойствами. Custom Elements могут быть созданы с использованием классов JavaScript и специальных методов для регистрации новых элементов.
2. **Shadow DOM**: Это технология, предоставляющая инкапсуляцию стилей и разметки веб-компонентов. Shadow DOM позволяет создавать изолированные "тенистые" деревья элементов, которые не влияют на глобальные стили приложения и не подвержены изменениям из внешнего кода.
3. **HTML Templates**: Это спецификация для создания шаблонов HTML-разметки, которые могут быть клонированы и добавлены в DOM при необходимости. Шаблоны создаются с использованием тега `<template>` и могут содержать любые HTML-элементы, стили и скрипты. Содержимое шаблонов не отображается и не выполняется до тех пор, пока оно не будет явно добавлено в DOM.
4. **HTML Imports**: Это спецификация, позволяющая импортировать HTML-документы в другие HTML-документы. Однако HTML Imports не получили широкой поддержки браузерами, и в настоящее время сообщество предпочитает использовать модули JavaScript (ES6) для импорта и управления зависимостями.

```jsx
// Пример создания веб-компонента с использованием Custom Elements и Shadow DOM
class MyComponent extends HTMLElement {
  constructor() {
    super();
    const shadowRoot = this.attachShadow({ mode: 'open' });
    shadowRoot.innerHTML = `
      <style>
        p {
          color: blue;
        }
      </style>
      <p>Hello, I'm a web component!</p>
    `;
  }
}

customElements.define('my-component', MyComponent);

//html
<my-component></my-component>
```

### Мемоизация

Кеширование результатов выполнения функции на основе переданных элементов.

Если функция вызывается с теми же аргументами, вместо повторного выполнения вычислений она возвращает сохраненный результат из кеша.

```jsx
// Без мемоизации. Функция очень медленно работает для больших значений n
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// С мемоизацией
function memoize(fn) {
  const cache = {};

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache[key] !== undefined) {
      return cache[key];
    }

    const result = fn.apply(this, args);
    cache[key] = result;
    return result;
  };
}

const memoizedFibonacci = memoize(fibonacci);
```

### Оптимизация времени загрузки страницы

1. **Анализ и мониторинг:**
    - Google Lighthouse: инструмент для анализа производительности, доступности, SEO и других аспектов веб-страницы.
    - Google PageSpeed Insights: сервис, предоставляющий информацию о производительности и рекомендации по оптимизации загрузки страницы.
    - WebPageTest: сервис для тестирования производительности веб-страницы из разных регионов и на разных устройствах.
2. **Оптимизация изображений:**
    - TinyPNG, ImageOptim или другие инструменты сжатия изображений, которые уменьшают размер файлов без значительной потери качества.
    - Использование форматов изображений, таких как WebP, которые предоставляют лучшее сжатие и производительность.
3. **Минификация и сжатие кода:**
    - UglifyJS или Terser для минификации JavaScript-кода.
    - CSSNano или CleanCSS для минификации CSS-кода.
    - HTMLMinifier для минификации HTML-кода.
    - Gzip или Brotli для сжатия ресурсов на сервере перед отправкой на клиент.
4. **Сборка и оптимизация кода:**
    - Webpack, Rollup или Parcel для сборки и оптимизации кода, объединения файлов и управления зависимостями.
5. **Оптимизация кеширования:**
    - Настройка HTTP-заголовков кеширования на сервере для оптимального использования кеша браузера.
    - Использование сервис-воркеров для управления кешированием ресурсов и оффлайн-доступом.
6. **Оптимизация загрузки ресурсов:**
    - Использование технологии HTTP/2 для многопоточной загрузки ресурсов и уменьшения задержек.
    - Ленивая загрузка (lazy loading) изображений и других элементов, которые не являются критическими для первоначального отображения страницы.
    - Применение техники код разделения (code splitting) для загрузки только тех частей кода, которые необходимы для конкретного маршрута или функции.
7. **Content Delivery Network (CDN):**
    - Использование CDN для распределения статических ресурсов, таких как изображения, стили и скрипты, с серверов, находя

## События

### Типы

- Toggle
    1. **Клавиатурные события:**
        - keydown: возникает при нажатии клавиши
        - keyup: возникает при отпускании клавиши
        - keypress: возникает при нажатии клавиши, которая производит символ (например, буква или цифра)
    2. **События мыши:**
        - click: возникает при клике мышью
        - dblclick: возникает при двойном клике мышью
        - mousedown: возникает при нажатии кнопки мыши
        - mouseup: возникает при отпускании кнопки мыши
        - mousemove: возникает при перемещении курсора мыши
        - mouseover: возникает, когда курсор мыши наводится на элемент
        - mouseout: возникает, когда курсор мыши покидает элемент
        - mouseenter: возникает, когда курсор мыши наводится на элемент (не всплывает)
        - mouseleave: возникает, когда курсор мыши покидает элемент (не всплывает)
        - contextmenu: возникает при вызове контекстного меню (обычно правой кнопкой мыши)
    3. **События формы:**
        - submit: возникает при отправке формы
        - reset: возникает при сбросе формы
        - change: возникает при изменении значения элемента формы
        - input: возникает при вводе данных в элемент формы
        - focus: возникает при получении фокуса элементом
        - blur: возникает при потере фокуса элементом
        - select: возникает при выборе текста в элементе формы
    4. **События окна и документа:**
        - load: возникает, когда страница или ресурс полностью загружен
        - unload: возникает при закрытии окна или переходе на другую страницу
        - beforeunload: возникает перед unload, позволяя запросить подтверждение пользователя на закрытие страницы
        - resize: возникает при изменении размера окна
        - scroll: возникает при прокрутке окна или элемента
        - DOMContentLoaded: возникает, когда HTML-документ был полностью загружен и разобран, но до загрузки стилей, изображений и других ресурсов
    5. **События сенсорного экрана (для мобильных устройств):**
        - touchmove: возникает при перемещении пальца по сенсорному экрану
        - touchcancel: возникает, когда система отменяет касание на сенсорном экране (например, когда палец двигается слишком быстро)
    6. **События, связанные с драг-н-дроп:**
        - drag: возникает при перетаскивании элемента
        - dragstart: возникает при начале перетаскивания элемента
        - dragend: возникает при завершении перетаскивания элемента
        - dragenter: возникает, когда перетаскиваемый элемент входит в допустимую зону для сброса
        - dragleave: возникает, когда перетаскиваемый элемент покидает допустимую зону для сброса
        - dragover: возникает, когда перетаскиваемый элемент находится над допустимой зоной для сброса
        - drop: возникает, когда перетаскиваемый элемент отпускается над допустимой зоной для сброса
    7. **События анимации и переходов CSS:**
        - animationstart: возникает, когда анимация начинается
        - animationend: возникает, когда анимация завершается
        - animationiteration: возникает, когда анимация завершает одну итерацию и начинает следующую
        - transitionend: возникает, когда переход CSS завершается
    8. **События мультимедиа (для аудио и видео):**
        - play: возникает, когда воспроизведение начинается
        - pause: возникает, когда воспроизведение приостанавливается
        - ended: возникает, когда воспроизведение завершается
        - timeupdate: возникает, когда текущее время воспроизведения изменяется
        - volumechange: возникает, когда уровень громкости изменяется
        - loadedmetadata: возникает, когда метаданные (например, длительность) загружены
        - loadeddata: возникает, когда данные начинают загружаться (например, первый кадр видео)

### Добавление/удаление обработчика события на страницу

```jsx
const testFunc = () => console.log('Hello world!');

// Inline event handler
<button onclick="testFunc()">Press me</button>

// Event handler properties
const btn = document.querySelector('button');
btn.onclick = testFunc();

// Function 'addEventListener'
const btn = document.querySelector('button');
btn.addEventListener('click', testFunc);
btn.removeEventListener('click', testFunc);
```

`addEventListener` принимает 3 аргумента - событие, функция, и опции.

Если в опцию передается логическое значение, оно определяет, должен ли обработчик вызываться в фазе перехвата (`true`) или всплытия (`false`).

Если передается объект с опциями, он может содержать следующие свойства:

- capture (логическое значение): Определяет, должен ли обработчик вызываться в фазе перехвата (`true`) или всплытия (`false`). По умолчанию равно `false`.
- once (логическое значение): Если установлено значение `true`, обработчик будет автоматически удален после первого вызова. По умолчанию равно `false`.
- passive (логическое значение): Если установлено значение `true`, обработчик не будет вызывать `event.preventDefault()`. Это может быть полезно для оптимизации производительности в некоторых случаях, например, при обработке событий прокрутки. По умолчанию равно `false`.

### Pointer Events

Спецификация API, предоставляющая единый механизм для работы с событиями, связанными с указателями, такими как мышь, сенсорный экран и перо (стилус).

Вместо того чтобы использовать разные обработчики событий для разных видов устройств ввода (например, `touchstart`, `mousedown`, `touchmove`, `mousemove`
 и т. д.)

В React надо добавить `on`. например `onpointerdown`**,** `onpointerup`.

**Основные события Pointer Events:**

1. `pointerdown`: возникает, когда указатель начинает взаимодействовать с элементом (например, нажатие мыши или касание сенсорного экрана).
2. `pointerup`: возникает, когда указатель прекращает взаимодействовать с элементом (например, отпускание кнопки мыши или отрыв пальца от сенсорного экрана).
3. `pointermove`: возникает, когда указатель перемещается над элементом.
4. `pointerenter`: возникает, когда указатель входит в область элемента.
5. `pointerleave`: возникает, когда указатель выходит из области элемента.
6. `pointerover`: возникает, когда указатель перемещается над элементом или его дочерними элементами.
7. `pointerout`: возникает, когда указатель покидает элемент или его дочерние элементы.
8. `gotpointercapture`: возникает, когда элемент начинает получать события от указателя.
9. `lostpointercapture`: возникает, когда элемент перестает получать события от указателя.

### Распространение события Event Propagation

Механизм который отрабатывает, когда какое-либо событие происходит в документе.

1. Capturing, погружение - событие идет от корня документа под DOM-дереву до целевого элемента.
2. Target, целевой элемент, event target - событие достигает целевого элемента.
3. Bubbling, всплытие - событие возвращается до корня документа, параллельно вызывая все события на родительских элементах.

### `event.target` и `event.currentTarget`

`event.target` - это элемент, на котором фактически произошло событие, и остается неизменным на протяжении всей фазы распространения события

`event.currentTarget` - это элемент, на котором установлен обработчик событий. Значение изменяется на каждом этапе распространения события.

### Делегирование события Event Delegation

Вместо того чтобы вешать кучу однотипных обработчиков на все элементы можно добавить один на общего предка. Отслеживается через `event.target`

### `stopPropagation()` и `stopImmediatePropagation()`

Предотвращяют распространение событий в DOM

`stopPropagation()` - на текущем элементе все обработчики сработают, дальше нет.

`stopImmediatePropagation()` - на текущем элементе сработает только обработчик с `ним`, другие обработчики не сработают, дальше тоже не сработают

### `load` и `DOMContentLoaded`

`DOMContentLoaded` - браузер загрузил html и построил DOM-дерево, внешние ресурсы (стили, скрипты, картинки) не загружены.

`load` - браузер загрузил html, построил DOM-дерево и загрузил внешние ресурсы.

### Синтетические события, Synthetic Events

Кроссбраузерная оболочка для нативных событий браузера.

Обертка вокруг событий браузера, предоставляющая единый API для работы с событиями в разных браузерах. Для определения обработчиков событий в компонентах.

# React

### **Особенности**

- Повышение производительность благодаря VirtualDOM.
- JSX облегчает написание и чтение кода.
- SSR через React DOM Server, Next.js, Gatsby.
- Однонаправленный поток данных, one-way direction data flow - данные передаются от корневых компонентов во вложенные, но не в обратном направлении.
- Переиспользуемые компоненты, reusable components.
- Декларативность - разработчик описывает желаемое состояние интерфейса, а не шаги для достижения этого состояния.

### JSX

Cинтаксическое расширение для JavaScript, которое позволяет описывать структуру интерфейса и его компоненты с использованием похожего на HTML синтаксиса.

Не строка и не HTML. Преобразуется сборщиком или Babel в обычный JS.

### React fiber

Новая архитектура React, которая была разработана для решения проблем с производительностью и поддержки новых функций, таких как асинхронный рендеринг, приоритизация задач и обработка прерываний.

**Основные особенности:**

1. **Инкрементальный рендеринг:** Fiber позволяет разбивать работу по рендерингу на более мелкие части, которые могут выполняться в разное время. Это обеспечивает лучшую производительность и позволяет избегать блокирования основного потока браузера на длительное время.
2. **Приоритизация задач:** Fiber позволяет назначать приоритеты различным задачам обновления. Например, обработка взаимодействия пользователя может быть более важной, чем обновление фоновых данных. Это помогает улучшить отзывчивость пользовательского интерфейса и предотвращает "замирания".
3. **Обработка прерываний:** Fiber может откладывать или прерывать выполнение некоторых задач, если они не являются приоритетными. Это позволяет браузеру выполнять другие критические задачи, такие как обработка событий или анимации.
4. **Поддержка новых функций:** Fiber позволил внедрить новые функции в React, такие как Concurrent Mode и Suspense, которые улучшают производительность и разработку приложений.

### Условный рендеринг

Так как в JSX нет условия `if...else`, можно использовать `&&` или `тернарный оператор`

### React-ссылка, Ref

Позволяет получить доступ к экземпляру конкретного DOM-элемента или компонента в React-приложении. 

Возвращает ссылку на элемент, аналог `getElementById()`

**Создание:**

`React.createRef()` - в классовом компоненте

`useRef()` - в функциональном компоненте

### Хуки, hooks

Позволяют использовать состояние и другие возможности React в функциональных компонентах, без необходимости преобразования их в классовые компоненты.

Легче работать, легче тестировать как отдельные функции компонентов, делают код чище, улучшают читаемость, сложная логика может быть вынесены в кастомный хук, повышают уровень переиспользуемости кода, снимают необходимость использования HOC.

Должны находиться в самом верху иерархии функции

Вызывать можно только в функциях, функциональных компонентах или кастомных хуках.

1. **useState** — позволяет использовать состояние локально в функциональном компоненте. Возвращает массив с двумя элементами: текущим значением состояния и функцией для обновления этого состояния.
    
    ```jsx
    const [state, setState] = useState(initialState);
    ```
    
2. **useEffect** — выполняет побочные эффекты в функциональных компонентах, например, запросы к API, подписки или изменение DOM. Принимает два аргумента: функцию с побочным эффектом и массив зависимостей. Если массив зависимостей пуст, эффект выполняется только при монтировании и размонтировании компонента.
    
    ```jsx
    useEffect(() => {
      // Код побочного эффекта
    
      return () => {
        // Очистка, выполняемая при размонтировании компонента
      };
    }, [dependencies]);
    ```
    
3. **useContext** — позволяет использовать контекст (Context) в функциональном компоненте. Принимает контекст, созданный с помощью `React.createContext`, и возвращает текущее значение этого контекста.
    
    ```jsx
    const contextValue = useContext(MyContext);
    ```
    
4. **useReducer** — альтернатива `useState` для более сложного управления состоянием. Принимает редьюсер (reducer) и начальное состояние, возвращает текущее состояние и функцию `dispatch` для отправки действий.
    
    ```jsx
    const [state, dispatch] = useReducer(reducer, initialState);
    ```
    
5. **useRef** — создает изменяемый объект-ссылку, который сохраняет свое значение между рендерами. Обычно используется для доступа к DOM-элементам или сохранения значения между рендерами без вызова обновления компонента.
    
    ```jsx
    const myRef = useRef(initialValue);
    ```
    
6. **useMemo** — мемоизирует значение, чтобы избежать его пересоздания при каждом рендере. Принимает функцию, которая возвращает значение, и массив зависимостей. Если зависимости не изменились, хук возвращает предыдущее значение.
    
    ```jsx
    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
    ```
    
7. **useCallback** — мемоизирует функцию, чтобы избежать ее пересоздания при каждом рендере. Принимает функцию и массив зависимостей. Если зависимости не изменились, хук возвращает предыдущую функцию. Это полезно при передаче функций в оптимизированные дочерние компоненты, чтобы избежать ненужных рендеров.
    
    ```jsx
    const memoizedCallback = useCallback(() => {
      // Действия, выполняемые функцией
    }, [dependencies]);
    ```
    
8. **useImperativeHandle** — позволяет создавать пользовательский экземпляр компонента, передаваемый в родительский компонент через `ref`. Обычно используется совместно с `forwardRef`. Принимает функцию, которая возвращает объект с определенными методами и свойствами, и массив зависимостей.
    
    ```jsx
    useImperativeHandle(ref, () => ({
      // Методы и свойства, доступные в родительском компоненте
    }), [dependencies]);
    ```
    
9. **useLayoutEffect** — выполняет побочные эффекты, аналогичные `useEffect`, но синхронно после всех изменений DOM. Используется в редких случаях, когда необходимо измерять DOM-узлы или изменять их синхронно в ответ на изменения состояния.
    
    ```jsx
    useLayoutEffect(() => {
      // Код побочного эффекта
    }, [dependencies]);
    ```
    
10. **useDebugValue** — позволяет добавить текстовую метку к пользовательскому хуку, которая отображается в инструментах разработчика React при инспектировании хуков.
    
    ```jsx
    useDebugValue(label);
    ```
    

### Virtual DOM

DOM не был рассчитан на создание динамического пользовательского интерфейса. Очень много DOM-узлов.

Объект -легковесное представление реального DOM-дерева, которое облегчает вычисление различий между текущим и новым состоянием интерфейса.

1. Когда происходит изменение состояния компонента, React создает новое виртуальное DOM-дерево, которое отражает обновленное состояние интерфейса.
2. React сравнивает новое виртуальное DOM-дерево со старым виртуальным DOM-деревом, чтобы определить различия между ними. Этот процесс называется "согласование" **(reconciliation)**.
3. После определения различий React обновляет реальное DOM-дерево, применяя только те изменения, которые необходимы для приведения реального DOM-дерева в соответствие с новым виртуальным DOM-деревом.
4. Затем браузер рендерит обновленное реальное DOM-дерево на экране.

### Shadow DOM

Используется для инкапсуляции и изоляции компонентов. Встроен в браузер.

### ReactDOM

Библиотека, которая предоставляет методы для работы с DOM в контексте React-приложений. Служит связующим звеном между React-компонентами и реальным DOM, обеспечивая отображение и обновление компонентов на веб-странице.

**Методы:**

1. `ReactDOM.render()` **-** для отображения React-компонента в DOM.
2. `ReactDOM.unmountComponentAtNode()` - удаляет React-компонент из DOM и выполняет очистку всех ресурсов, связанных с компонентом.

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

const container = document.getElementById('root');
ReactDOM.render(<App />, container);

// В какой-то момент времени мы решаем удалить компонент
ReactDOM.unmountComponentAtNode(container);
```

### React DOM Server

Библиотека для SSR. Улучшение производительности и SEO.

Используется вместе с Node.js и Express.

Альтернативы: Next.js, Gatsby, React Server Components.

### Атрибут `key`

Благодаря этому атрибуту, React может определить, какие элементы были добавлены, изменены или удалены, и выполнять минимальное количество операций с DOM для обновления представления.

По умолчанию использует индексы массива в качестве ключей.

```jsx
const items = ['apple', 'banana', 'cherry'];

function ListItem({ item }) {
  return <li>{item}</li>;
}

function ItemList({ items }) {
  return (
    <ul>
      {items.map((item) => (
        <ListItem key={item} item={item} />
      ))}
    </ul>
  );
}
```

## Компоненты

Проект, шаблон или схема. Строительный блок приложения.

**Классовый** (c методами жизненного цикла) или **функциональный** (с хуками) компонент, описывающий визуальное представление приложения.

Возвращает элемент - объект, хранящийся в памяти, описывающий виртуальное представление DOM-узла, содержащегося в компоненте.

```jsx
import React, { useState } from 'react';

// Функциональный компонент
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}

// Классовый компонент
class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }

  incrementCount = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Счетчик: {this.state.count}</p>
        <button onClick={this.incrementCount}>Увеличить</button>
      </div>
    );
  }
}
```

Контейнер - неофициальное название компонента, подключенного к хранилищу Redux. Подписываются на обновление состояния Redux и диспатчат операции. Посредник между хранилищем и компонентом интерфейса.

### Состояние и пропсы

Пропсы передаются компонентам (как аргументы) от их родителей.
Состояние управляется компонентом как переменная, объявленная внутри функции.

Пропсы используются для передачи данных между компонентами
Состояние используется для хранения и изменения данных, которые влияют на отображение и поведение компонента.

**Пропсы (Props):**

1. Аргументы, передаваемые компонентам от родительских компонентов. Они предоставляют данные и/или обработчики событий для компонентов.
2. Пропсы являются внешними данными для компонента и передаются сверху вниз в иерархии компонентов.
3. Пропсы неизменны, и их нельзя изменить внутри компонента, который их получает.
4. Пропсы используются для передачи данных и информации между компонентами.

**Состояние (State):**

1. Внутренний объект данных компонента, который может изменяться во время жизненного цикла компонента.
2. Состояние инициализируется и управляется самим компонентом, хотя его изменения могут влиять на дочерние компоненты.
3. Состояние изменяется с использованием функции `setState` (в классовых компонентах) или хука `useState` (в функциональных компонентах).
4. Состояние используется для управления динамическим поведением компонента или для хранения данных, которые могут изменяться во время работы компонента.

### Prop Drilling

Процесс передачи пропсов от верхнего компонента вниз через промежуточные компоненты, даже если эти промежуточные компоненты не используют эти пропсы.

Для решения проблемы используют context или Redux.

```jsx
function GrandParent() {
  const [value, setValue] = useState('Some data');

  return <Parent value={value} />;
}

function Parent(props) {
  return <Child value={props.value} />;
}

function Child(props) {
  return <div>{props.value}</div>;
}
```

### Context

Передача данных от родительского к дочерним компонентам, без необходимости передавать их явно через props. Тема оформления, язык приложения, состояние аутентификации

```jsx
// Создаем контекст
const MyContext = React.createContext(defaultValue);

// Создаем провайдер для передачи контекста дочерним компонентам
<MyContext.Provider value={someValue}>
  {/* Дочерние компоненты, которым нужен доступ к контексту */}
</MyContext.Provider>

// Используем контекст в дочерних компонентах с помощью 
// React.useContext (для функциональных компонентов) и
// contextType (для классовых компонентов)
// Функциональный компонент
function MyComponent() {
  const contextValue = React.useContext(MyContext);
  // теперь у вас есть доступ к значению контекста
}

// Классовый компонент
class MyComponent extends React.Component {
  static contextType = MyContext;

  render() {
    const contextValue = this.context;
    // теперь у вас есть доступ к значению контекста
  }
}
```

### PropTypes

Библиотека для проверка типа передаваемого props.

```jsx
import React from 'react';
import PropTypes from 'prop-types';

function Welcome(props) {
  return <h1>Привет, {props.name}!</h1>;
}

Welcome.propTypes = {
  name: PropTypes.string.isRequired,
};

Welcome.defaultProps = {
  name: '',
};

export default Welcome;
```

### Fragment

Специальный тег, который не отрисовывается внутри реального DOM-дерева.

```jsx
<Fragment>
	<Component1 />
	<Component2 />
	<Component1 />
</Fragment>

// Новый синтаксис
<>
	<Component1 />
	<Component2 />
	<Component1 />
</>
```

Лучше `<div>`, потому что используют меньше памяти, не ломает макет страницы, удобнее пользоваться инспектором.

### Children

Cпособ передачи дочерних элементов внутри компонента.

```jsx
// App.jsx
<Box>
  <h2>Заголовок в коробке</h2> // Это отрисовываться не будет, 
  <p>Текст в коробке</p> // а просто передается в компонент
</Box>

//Box.jsx
function Box(props) {
  return <div className="box">{props.children}</div>;
}

// html
<div class="box">
  <h2>Заголовок в коробке</h2>
  <p>Текст в коробке</p>
</div>
```

### StrictMode

Если приложение или его часть обернуты в `<StrictMode>`, React будет проверять код на наличие устаревших или небезопасных практик. Компонент не рендерит никакого видимого пользовательского интерфейса и не влияет на работу вашего приложения в продакшене.

`StrictMode` выполняет следующие проверки и действия:

1. Выявляет устаревшие методы жизненного цикла (такие как `componentWillMount`, `componentWillReceiveProps` и `componentWillUpdate`).
2. Предупреждает о неправильном использовании ключевого слова `ref` (например, передаче строковых значений вместо функций или объектов с `React.createRef()`).
3. Проверяет на использование устаревших API, таких как `findDOMNode`.
4. Предупреждает об использовании унаследованного контекста, который считается устаревшим.
5. Проверяет неправильное использование React-ссылок (Refs) в функциональных компонентах.
6. Предупреждает о возможных проблемах с производительностью, таких как обнаружение неожиданных изменений состояния во время фазы рендеринга.

```jsx
import React, { StrictMode } from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
  <StrictMode>
    <App />
  </StrictMode>,
  document.getElementById('root')
);
```

### Pure component, чистый компонент

Класс компонента в React, который наследует от класса `React.PureComponent`.

Реализует поверхностное сравнение состояния и свойств (`props`) для определения, следует ли перерисовывать компонент. Это может улучшить производительность, так как оно предотвращает ненужные перерисовки, если данные компонента не изменились.

В обычном компоненте метод `shouldComponentUpdate` по умолчанию всегда возвращает `true`. Это означает, что компонент будет перерисовываться при любом изменении состояния или свойств, даже если они на самом деле не изменились.

В чистом компоненте метод `shouldComponentUpdate` реализует поверхностное сравнение состояния и свойств. Если сравнение показывает, что состояние и свойства не изменились, то метод возвращает `false` и компонент не перерисовывается. Это может быть полезно для оптимизации производительности, особенно в больших приложениях.

Может быть неэффективным, если у данных сложная структура, или если часто создаются новые объекты со старыми данными.

### Компонент-переключатель, Switch Component

Отображает один из нескольких вариантов контента в зависимости от текущего состояния или условия. Для переключения между разделами сайта или вкладками диалогового окна.

```jsx
import React, { useState } from 'react';

function SwitchComponent() {
  const [view, setView] = useState('home');

  const renderView = () => {
    switch (view) {
      case 'home':
        return <div>Домашняя страница</div>;
      case 'about':
        return <div>О нас</div>;
      case 'contact':
        return <div>Контакты</div>;
      default:
        return <div>Домашняя страница</div>;
    }
  };

  return (
    <div>
      <button onClick={() => setView('home')}>Домашняя страница</button>
      <button onClick={() => setView('about')}>О нас</button>
      <button onClick={() => setView('contact')}>Контакты</button>
      {renderView()}
    </div>
  );
}

// В зависимости от значения view, функция renderView возвращает
// разный контент для отображения.
```

### Предохранители ошибок, Error Boundaries

Компоненты, которые позволяют обрабатывать ошибки, возникающие в дочерних компонентах, и предотвращать их распространение вверх по дереву компонентов.

При ошибке, приложение не ломается и не показывает белый экран, отображается запасной интерфейс с ошибкой.

### Ленивая функция, Lazy loading

Позволяет загружать компоненты по мере необходимости.

Компонент `Suspense` обязателен при использовании `React.lazy()` . Служит для определения заглушки (фоллбэка) во время загрузки компонента. Заглушка будет отображаться до тех пор, пока лениво загружаемый компонент не будет готов к рендерингу.

```jsx
import React, { lazy, Suspense } from "react";

const MyComponent = lazy(() => import("./MyComponent"));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <MyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

### Компонент высшего порядка, high-order component, HOC

Функция, которая принимает компонент и возвращает новый компонент с дополнительными свойствами или функциональностью.

```jsx
function withViewCounter(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        viewsCount: 0,
      };
    }

    componentDidMount() {
      // Увеличиваем счетчик при монтировании компонента
      this.setState({ viewsCount: this.state.viewsCount + 1 });
    }

    render() {
      // Передаем счетчик просмотров в исходный компонент
      return <WrappedComponent viewsCount={this.state.viewsCount} {...this.props} />;
    }
  };
}

// Используем этот HOC для оборачивания страниц продуктов
function ProductPage({ product, viewsCount }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <p>Просмотров: {viewsCount}</p>
    </div>
  );
}

const EnhancedProductPage = withViewCounter(ProductPage);
```

### Инверсия наследования, Inheritance Inversion

Паттерн, который инвертирует традиционное направление наследования с целью переиспользования кода и облегчения работы с компонентами.

Вместо того чтобы создавать базовый класс или компонент и наследовать от него, инверсия наследования предполагает, что вы создаете HOC, который принимает компонент (обычно в качестве аргумента) и возвращает новый компонент, расширяющий или модифицирующий функциональность исходного компонента.

```jsx
// Компонент высшего порядка (HOC) для добавления состояния к любому компоненту
function withState(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = { value: '' };
    }

    handleChange = (event) => {
      this.setState({ value: event.target.value });
    };

    render() {
      return (
        <WrappedComponent
          {...this.props}
          value={this.state.value}
          handleChange={this.handleChange}
        />
      );
    }
  };
}

// Простой компонент Input
function Input({ value, handleChange }) {
  return <input value={value} onChange={handleChange} />;
}

// Создание нового компонента с инверсией наследования
const EnhancedInput = withState(Input);

function App() {
  return (
    <div>
      <EnhancedInput />
    </div>
  );
}
```

### Управляемые и неуправляемые компоненты

Управляемые компоненты используют состояние React для хранения и изменения значений полей ввода. React контролирует значение полей ввода и их изменения.

Неуправляемые компоненты используют нативное поведение DOM-элементов и ссылки на них.

### Двустороннее связывание, two-way binding

Позволяет синхронизировать данные между состоянием компонента и UI.

Данные, изменяющиеся в представлении, обновляют состояние.
Данные в состоянии, обновляют представление.

Данные, вводимые на UI попадают в state и обновляют его.
Обновление state вызывает обновление на UI.

Реализуется с помощью `useState()` и обработчика

```jsx
import React, { useState } from 'react';

function App() {
  // Объявляем состояние `text` с помощью хука useState
  const [text, setText] = useState('');

  // Функция-обработчик изменения ввода
  const handleChange = (event) => {
    setText(event.target.value);
  };

  return (
    <div>
      <input type="text" value={text} onChange={handleChange} />
      <p>Введенный текст: {text}</p>
    </div>
  );
}

export default App;
```

### Стадии и методы жизненного цикла компонента в React

1. Монтирование - компонент готов к встраиванию в DOM браузера:
    - `constructor(props)`: конструктор компонента, вызывается при создании экземпляра компонента.
    - `static getDerivedStateFromProps(props, state)`: вызывается перед `render` при создании компонента и при получении новых свойств. Используется для синхронизации состояния компонента с изменением свойств.
    - `render()`: метод, который определяет, как компонент должен быть отрисован.
    - `componentDidMount()`: вызывается после того, как компонент был вставлен в DOM. Здесь можно выполнять асинхронные запросы, подписываться на события и т.д.
2. Обновление - компонент получает новые свойства или изменяется его состояние.:
    - `static getDerivedStateFromProps(props, state)`: см. выше.
    - `shouldComponentUpdate(nextProps, nextState)`: вызывается перед обновлением компонента, когда приходят новые свойства или изменяется состояние. Возвращает `true` или `false`, что определяет, следует ли обновлять компонент.
    - `render()`: см. выше.
    - `getSnapshotBeforeUpdate(prevProps, prevState)`: вызывается перед фактическим обновлением DOM, после вычисления нового результата от `render()`. Возвращает значение, которое будет передано в `componentDidUpdate`.
    - `componentDidUpdate(prevProps, prevState, snapshot)`: вызывается сразу после обновления DOM. Здесь можно выполнять дополнительные манипуляции с DOM, обрабатывать ответы на запросы и т.д.
3. Размонтирование - удаление компонента из DOM:
    - `componentWillUnmount()`: вызывается перед удалением компонента из DOM. Здесь можно выполнить необходимую очистку, такую как отмена таймеров, отписка от событий и т.д.

Обратите внимание, что для функциональных компонентов, использующих хуки, жизненный цикл управляется с помощью хуков `useState`, `useEffect` и других.

Также стоит отметить, что следующие методы жизненного цикла объявлены устаревшими начиная с React 16.3 и будут удалены в будущих версиях:

- `componentWillMount()`
- `componentWillReceiveProps(nextProps)`
- `componentWillUpdate(nextProps, nextState)`

Монтирование происходит один раз, компонент создается и вставляется в DOM.

Рендеринг может происходить несколько раз из-за изменения состояния или обновлении props.

### Portal

Позволяет рендерить дочерние элементы компонента в произвольную часть DOM-дерева. Модальные окна, всплывающие подсказки или выпадающие меню.

Позволяют избегать проблем с CSS-позиционированием, таких как перекрытие, z-индекс и видимость элементов. Также порталы сохраняют контекст и события вашего приложения, даже если элементы рендерятся в другом месте DOM.

```jsx
import ReactDOM from 'react-dom';

function MyPortalComponent({ children }) {
  const portalRoot = document.getElementById('portal-root');

  return ReactDOM.createPortal(
    children,
    portalRoot
  );
}
```

## Redux

### FLux

Архитектурный подход или шаблон проектирования, разработанный Facebook для построения клиентских веб-приложений. Он предназначен для управления потоком данных в приложениях на основе React, создавая однонаправленный поток данных и делая состояние приложения более предсказуемым.

**Flux состоит из следующих основных компонентов:**

1. **Действия (Actions):** Действия представляют собой простые объекты, которые описывают изменения или события в системе. Они обычно создаются с помощью функций-генераторов действий (action creators) и содержат тип действия и любые необходимые данные.
2. **Диспетчер (Dispatcher):** Диспетчер — это центральный хаб, который обрабатывает все действия и передает их соответствующим обработчикам в хранилищах. В Flux приложении обычно присутствует только один диспетчер.
3. **Хранилища (Stores):** Хранилища содержат состояние приложения и логику его изменения. Они подписываются на действия, поступающие из диспетчера, и обновляют свое состояние соответственно. Хранилища также могут генерировать события об изменении состояния, на которые подписываются компоненты.
4. **Компоненты (Components):** Компоненты React отвечают за отображение данных из хранилищ и генерацию действий на основе пользовательского ввода. Компоненты подписываются на обновления состояния из хранилищ и обновляются соответственно.

Основное отличие Flux от традиционных двунаправленных систем привязки данных заключается в том, что он создает ясную разделительную линию между различными частями приложения и обеспечивает однонаправленный поток данных. Это упрощает управление состоянием и делает поведение приложения более предсказуемым.

Flux — это архитектурный подход, а не конкретная библиотека или фреймворк. Существует множество реализаций Flux, таких как Redux, Reflux, MobX и других, которые следуют основным принципам Flux и предоставляют дополнительные возможности или упрощения.

### Redux

Библиотека для управления состоянием приложения, которая часто используется совместно с React. Она позволяет централизовать данные и логику изменения состояния, делая приложение более предсказуемым и упрощая отладку. Основана на Flux.

Простым языком, Redux создаёт глобальное "хранилище" (store) для хранения состояния вашего приложения. Это состояние может быть любыми данными, например, информацией о пользователе, списком товаров, фильтрами и т. д. Вместо того чтобы хранить и изменять эти данные внутри компонентов, вы используете Redux, чтобы все компоненты имели доступ к общим данным.

**Плюсы:**

- Получение состояния без передачи пропсов
- Состояние сохраняется при размонтировании компонента
- Предотвращение повторных рендерингов
- Разделение интерфейса и управление состоянием

**Минусы:**

- Отсутствие инкапсуляции
- Много шаблонного кода, ограниченный дизайн
- Расходы памяти на обновление состояния

### Основные понятия

1. **Хранилище (Store)** — это место, где хранится состояние вашего приложения. Оно предоставляет методы для доступа к состоянию, обновления состояния и подписки на изменения состояния.
2. **Действия (Actions)** — это объекты, которые описывают, что именно должно произойти с состоянием приложения. Обычно действие содержит тип (type), который указывает, какое изменение нужно сделать, и полезную нагрузку (payload), которая содержит данные для этого изменения.
3. **Редьюсеры (Reducers)** — это чистые функции, которые принимают текущее состояние и действие, а затем возвращают новое состояние. Редьюсеры определяют, как именно изменяется состояние в ответ на действия.
Используют текущее состояние и action, операцию для определения нового состояния.

Когда вам нужно изменить состояние, вы отправляете (dispatch) действие в хранилище. Хранилище вызывает соответствующий редьюсер с текущим состоянием и действием, а редьюсер возвращает новое состояние. Затем хранилище оповещает все подписанные компоненты о том, что состояние изменилось, и компоненты обновляют свои данные.

Redux позволяет вам структурировать приложение так, чтобы состояние было предсказуемым и легко отслеживаемым, а также упрощает тестирование и отладку кода.

### **Принципы**

1. **Единое хранилище состояния (Single source of truth):** В Redux все состояние приложения хранится в одном JavaScript-объекте, называемом "хранилище" (store). Это облегчает отладку, управление состоянием и предоставляет возможность восстановления состояния приложения.
2. **Состояние доступно только для чтения (State is read-only):** В Redux состояние никогда не изменяется напрямую. Вместо этого, чтобы изменить состояние, вы должны создать "действие" (action), представляющее собой простой объект, который описывает, что должно произойти. Это гарантирует, что все изменения состояния можно отслеживать и предотвращает возникновение ошибок из-за случайных изменений состояния.
3. **Изменения состояния выполняются чистыми функциями (Changes are made with pure functions):** Чтобы обновить состояние в ответ на действие, Redux использует "редьюсеры" (reducers) — чистые функции, которые принимают предыдущее состояние и действие, а затем возвращают новое состояние. Редьюсеры должны быть чистыми функциями без побочных эффектов, что делает их легко тестируемыми и предсказуемыми.
4. **Однонаправленный поток данных (Unidirectional data flow):** Redux поддерживает однонаправленный поток данных, как и Flux, что обеспечивает ясное разделение ответственности между разными частями приложения и упрощает управление состоянием.

### **Ключевые концепции**

1. **Единое хранилище состояния (Store)**: Весь состояние вашего приложения хранится в одном месте, называемом хранилищем (store). Это делает управление состоянием более предсказуемым и прозрачным.
2. **Состояние доступно только для чтения (Read-only state)**: В Redux состояние приложения является доступным только для чтения. Это означает, что его нельзя напрямую изменять. Любые изменения состояния осуществляются только через специальные функции - редукторы.
3. **Редукторы (Reducers)**: Редуктор - это чистая функция, которая принимает текущее состояние и действие, а затем возвращает новое состояние. Редукторы являются основным механизмом изменения состояния в Redux. Они обрабатывают действия и создают новые версии состояния на основе переданных действий.
4. **Действия (Actions)**: Действия - это простые объекты, которые описывают, какое изменение состояния необходимо выполнить. Они имеют тип (type) и могут нести дополнительную информацию (payload) для изменения состояния. Действия передаются в хранилище с помощью функции `dispatch`.
5. **Подписка на изменения (Subscriptions)**: Redux позволяет компонентам "подписываться" на изменения состояния. Таким образом, когда состояние меняется, все подписанные компоненты получают обновленное состояние и перерисовываются с новыми данными.
6. **Промежуточное ПО (Middleware)**: Redux поддерживает промежуточное ПО (middleware), которое позволяет добавлять дополнительные функции, такие как асинхронные действия или логирование, в процесс передачи действий между компонентами и хранилищем.

### Поток данных

1. **Действие (Action):** Все изменения состояния приложения начинаются с создания действия. Действие - это простой JavaScript-объект, который содержит информацию о том, что должно произойти. Обычно действие имеет тип (type) и некоторые данные (payload).
2. **Отправка действия (Dispatch):** Действие отправляется в хранилище Redux с помощью функции `dispatch`. Это можно сделать из любого компонента, который подключен к хранилищу Redux.
3. **Редуктор (Reducer):** Редуктор - это чистая функция, которая принимает текущее состояние и отправленное действие, а затем возвращает новое состояние. Редуктор должен быть идемпотентным, то есть вызов редуктора с тем же состоянием и действием должен возвращать одинаковый результат.
4. **Обновление состояния (State update):** На основе результата работы редуктора, хранилище Redux обновляет свое состояние. Если состояние было изменено, Redux уведомляет все подключенные компоненты об этом.
5. **Обновление компонентов (Component update):** Подключенные компоненты получают обновленное состояние из хранилища и рендерят его. Если требуется отправить новое действие, процесс начинается снова с шага 1.

### Единственный источник истины, Single Source of Truth, SSOT

Все состояния приложения хранятся в одном хранилище.

**Преимущества использования:**

1. **Предсказуемость**: Централизованное хранение состояния делает управление данными предсказуемым и надежным. Это упрощает отладку и устранение ошибок, поскольку вам не нужно искать состояние по всему приложению.
2. **Контроль**: Единое хранилище состояния обеспечивает больше контроля над данными. Это позволяет вам точно знать, как изменяется состояние, и делает код менее подверженным ошибкам.
3. **Модульность**: Redux позволяет разбить состояние приложения на модули, каждый из которых имеет свой редуктор. Это делает код более модульным и легким для понимания и поддержки.
4. **Производительность**: Централизованное хранилище состояния может улучшить производительность приложения, поскольку оно позволяет оптимизировать обновление данных и избегать ненужных перерисовок компонентов.
5. **Отслеживание изменений**: С помощью единого источника истины можно легко отслеживать изменения состояния, что полезно для разработки и тестирования.
